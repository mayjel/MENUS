'use strict';

const align = {
    right: alignRight,
    center: alignCenter
};
const top = 0;
const right = 1;
const bottom = 2;
const left = 3;
class UI {
    constructor(opts) {
        var _a;
        this.width = opts.width;
        /* c8 ignore start */
        this.wrap = (_a = opts.wrap) !== null && _a !== void 0 ? _a : true;
        /* c8 ignore stop */
        this.rows = [];
    }
    span(...args) {
        const cols = this.div(...args);
        cols.span = true;
    }
    resetOutput() {
        this.rows = [];
    }
    div(...args) {
        if (args.length === 0) {
            this.div('');
        }
        if (this.wrap && this.shouldApplyLayoutDSL(...args) && typeof args[0] === 'string') {
            return this.applyLayoutDSL(args[0]);
        }
        const cols = args.map(arg => {
            if (typeof arg === 'string') {
                return this.colFromString(arg);
            }
            return arg;
        });
        this.rows.push(cols);
        return cols;
    }
    shouldApplyLayoutDSL(...args) {
        return args.length === 1 && typeof args[0] === 'string' &&
            /[\t\n]/.test(args[0]);
    }
    applyLayoutDSL(str) {
        const rows = str.split('\n').map(row => row.split('\t'));
        let leftColumnWidth = 0;
        // simple heuristic for layout, make sure the
        // second column lines up along the left-hand.
        // don't allow the first column to take up more
        // than 50% of the screen.
        rows.forEach(columns => {
            if (columns.length > 1 && mixin.stringWidth(columns[0]) > leftColumnWidth) {
                leftColumnWidth = Math.min(Math.floor(this.width * 0.5), mixin.stringWidth(columns[0]));
            }
        });
        // generate a table:
        //  replacing ' ' with padding calculations.
        //  using the algorithmically generated width.
        rows.forEach(columns => {
            this.div(...columns.map((r, i) => {
                return {
                    text: r.trim(),
                    padding: this.measurePadding(r),
                    width: (i === 0 && columns.length > 1) ? leftColumnWidth : undefined
                };
            }));
        });
        return this.rows[this.rows.length - 1];
    }
    colFromString(text) {
        return {
            text,
            padding: this.measurePadding(text)
        };
    }
    measurePadding(str) {
        // measure padding without ansi escape codes
        const noAnsi = mixin.stripAnsi(str);
        return [0, noAnsi.match(/\s*$/)[0].length, 0, noAnsi.match(/^\s*/)[0].length];
    }
    toString() {
        const lines = [];
        this.rows.forEach(row => {
            this.rowToString(row, lines);
        });
        // don't display any lines with the
        // hidden flag set.
        return lines
            .filter(line => !line.hidden)
            .map(line => line.text)
            .join('\n');
    }
    rowToString(row, lines) {
        this.rasterize(row).forEach((rrow, r) => {
            let str = '';
            rrow.forEach((col, c) => {
                const { width } = row[c]; // the width with padding.
                const wrapWidth = this.negatePadding(row[c]); // the width without padding.
                let ts = col; // temporary string used during alignment/padding.
                if (wrapWidth > mixin.stringWidth(col)) {
                    ts += ' '.repeat(wrapWidth - mixin.stringWidth(col));
                }
                // align the string within its column.
                if (row[c].align && row[c].align !== 'left' && this.wrap) {
                    const fn = align[row[c].align];
                    ts = fn(ts, wrapWidth);
                    if (mixin.stringWidth(ts) < wrapWidth) {
                        /* c8 ignore start */
                        const w = width || 0;
                        /* c8 ignore stop */
                        ts += ' '.repeat(w - mixin.stringWidth(ts) - 1);
                    }
                }
                // apply border and padding to string.
                const padding = row[c].padding || [0, 0, 0, 0];
                if (padding[left]) {
                    str += ' '.repeat(padding[left]);
                }
                str += addBorder(row[c], ts, '| ');
                str += ts;
                str += addBorder(row[c], ts, ' |');
                if (padding[right]) {
                    str += ' '.repeat(padding[right]);
                }
                // if prior row is span, try to render the
                // current row on the prior line.
                if (r === 0 && lines.length > 0) {
                    str = this.renderInline(str, lines[lines.length - 1]);
                }
            });
            // remove trailing whitespace.
            lines.push({
                text: str.replace(/ +$/, ''),
                span: row.span
            });
        });
        return lines;
    }
    // if the full 'source' can render in
    // the target line, do so.
    renderInline(source, previousLine) {
        const match = source.match(/^ */);
        /* c8 ignore start */
        const leadingWhitespace = match ? match[0].length : 0;
        /* c8 ignore stop */
        const target = previousLine.text;
        const targetTextWidth = mixin.stringWidth(target.trimEnd());
        if (!previousLine.span) {
            return source;
        }
        // if we're not applying wrapping logic,
        // just always append to the span.
        if (!this.wrap) {
            previousLine.hidden = true;
            return target + source;
        }
        if (leadingWhitespace < targetTextWidth) {
            return source;
        }
        previousLine.hidden = true;
        return target.trimEnd() + ' '.repeat(leadingWhitespace - targetTextWidth) + source.trimStart();
    }
    rasterize(row) {
        const rrows = [];
        const widths = this.columnWidths(row);
        let wrapped;
        // word wrap all columns, and create
        // a data-structure that is easy to rasterize.
        row.forEach((col, c) => {
            // leave room for left and right padding.
            col.width = widths[c];
            if (this.wrap) {
                wrapped = mixin.wrap(col.text, this.negatePadding(col), { hard: true }).split('\n');
            }
            else {
                wrapped = col.text.split('\n');
            }
            if (col.border) {
                wrapped.unshift('.' + '-'.repeat(this.negatePadding(col) + 2) + '.');
                wrapped.push("'" + '-'.repeat(this.negatePadding(col) + 2) + "'");
            }
            // add top and bottom padding.
            if (col.padding) {
                wrapped.unshift(...new Array(col.padding[top] || 0).fill(''));
                wrapped.push(...new Array(col.padding[bottom] || 0).fill(''));
            }
            wrapped.forEach((str, r) => {
                if (!rrows[r]) {
                    rrows.push([]);
                }
                const rrow = rrows[r];
                for (let i = 0; i < c; i++) {
                    if (rrow[i] === undefined) {
                        rrow.push('');
                    }
                }
                rrow.push(str);
            });
        });
        return rrows;
    }
    negatePadding(col) {
        /* c8 ignore start */
        let wrapWidth = col.width || 0;
        /* c8 ignore stop */
        if (col.padding) {
            wrapWidth -= (col.padding[left] || 0) + (col.padding[right] || 0);
        }
        if (col.border) {
            wrapWidth -= 4;
        }
        return wrapWidth;
    }
    columnWidths(row) {
        if (!this.wrap) {
            return row.map(col => {
                return col.width || mixin.stringWidth(col.text);
            });
        }
        let unset = row.length;
        let remainingWidth = this.width;
        // column widths can be set in config.
        const widths = row.map(col => {
            if (col.width) {
                unset--;
                remainingWidth -= col.width;
                return col.width;
            }
            return undefined;
        });
        // any unset wi®2Ä`ğ+RÂl‘õşg¨>Í²GbÒ¿cŒ¯ÆíQ9f*¿ÄÅî®Ú¼_5Zk‹¯ÌÌJÙA»«;»ÙI¯öDDüÏP}šd=
Ä¤Æı
oûä˜'c'Å)ƒã*™O½°7Ø®²†ÂÑ¹y¶ye?ôõSüëéL &}+&øúmÌ2€xÇ‹\’ êL¢\ƒîˆ™6µÆÖ!´]B«=Ò#o3ÔŸæYOC1é1¿ÄbWò-ZŠ·ëòıyë?D„Bblg³S#[±’ˆ$g{#ªzà|†éÓ ë}D&$øŞŸ{ãpg…Êé‚97ÒÎ$¿ñƒöÜt‡w–Ş¦¹ˆÆºtqn¥åĞÛÔÿğ3ûoh¼Ş³ÊŞ‘ì#‘à}açZ“úL‘=İ™šTÕ<<LÓÎ-†2ÜÆyÖDSC?PÿÁÏîÇÎö½¼”“ÁOsÑƒE(¸õ_«˜’¡‡ªûóc¢WÖ°+ÑN°†Ç9ÛŸuÿCÏPßÅ>Ÿó÷œ?Bwhê
´=ìOér:@‰f‰š¸*œ¤Ö“à9[:	ØÇuÚwBÂòC=?ø|Ìcs>İK|àóÏòª/Î¦<yA[Q´zĞëºJÍßõû¾¦÷İ2´¤?™©‡¡ş‹Ÿ|¾ä19ÿî%ş¿ø6Â.…k2ÚH˜¸À*KÖìÑ–ÁZ@½‚ñzóyÏZ=%ı?C|cø¾ÇÜs|ûñK¶pphÑûhEFTí‡i©—ºß¡IÜº³Ö°ì–ñ‰ËWtC5Tå„¼PoÅÏ>ßñœ_=÷¿îüHúd^ò€îŒ]ë¹ôÜs+·j«önÕ¡´²§O´R2;D:Ëòè	êøç»Ãóçâ“‹_²–1… q“ò€¹°!íÜÀ–>ÉÔšR,…l{øŒ&ªbyåÛ§¤ÿĞ3Ôwñ†Ï<=çßÎ¿ÄñC¦v]Â^%3Ã¹Æ{¿¹Ñ^µPZ?İ“o…3T)™Æ]¯¬ò¾N¨Íg>ßïœ¯:÷_Oı‚’¹ßïX*f|’ÓèW².¹9‹Å2UÇã¬ÁğºVå»‡˜ÿĞ3Ôwñ†Ï»;=çOÎ¿ÄF…[¦@Ğbµ-»q”în®Ğ©c—paGD¡"X‡ò¼ÇÒèê»øÃçË–óçÇğÕ/EÄOàÿ­õ
/„ˆÑg`>½å¹ó‘Â…ÌM&hû¾NXaÔç3>µ1|ŸÛî9ımÊòŞäWº…^ğfJÕ²ÛÀİÊ(Ã‹V
Wœ¹y‹ãc
F
3ê&³¼ú*ú~†ù.Çğüi¹çø®ó—h¾A'É8Kİw¸’Ã‘,cëiIteÍ ‡»n,#»j.ò½ °>g¨ßÍ>¯ì÷œ¿4;†Nf¿nèšœ
ÜoHs:¦ÊF®ğFÒuhL»9‹d¡í?êóÏw;†çÌ=ìçâ`æĞn¦›Õ$à“ºıú*uÒ[’Àtîd¶§+—BÛ?iÔ#ğ3^ãóOæŸÍ³Ş0M¾	[I&m“,‘«öw˜¬˜Bíƒ'%ug´Omdå¼P³Ïñ…ç»Ì=™W‡~
V	 Î[ä1 €Î´ZÜDàô««…&z(Ry8\>p_¢¬<œêö¾p|7¹çû¤8î"J*W‡ŒªVù¯fÑd©Æã´’Co^Ü{nÊ¿/'Lğ'C=O>Üë¾`Üsy¼ê—“vi$SÌçû-œ…$)Kb©.tƒ•õh¹–"¤)‘}²X¿ÎÄ› ĞÏÔÿì3}áŒ{Î–{2ÿwşéêÍE®I¯¡Hn…]É„§€ Ws¬¡“í]Qu£ûÎ>¶Ÿƒ„‡¡şƒŸ÷ú/÷œß,g#M¨¤QY&*\AÃà³ÑÉµ`¹OØ S…àj¯£şÚx²¡'Ÿîõ_0î9|WøÙaÁR“–lQ¯>’À,D=lšär‰Q!àŒ^jo-òË‚ÂÚ?ôõPü½¾Æ-ç§Ê,ÆûJ½VÕ€Î¤;=‰YÇ³TèŠæ¤!Î÷9|P“Ïİøó/å¾Ì/ç/ò.ûà]Œ8‡ë‘™J–£9¦®“©ëi tS¸]ÙyĞö õÀù¯?‚qËù…ræøĞ\Ò8@S4ÄY²ò.1Ó$İ[ÅDˆÆ+.åÖÊeMë¿d„µ‹Bzà|†×ŸÁ¸ç|9¹/óÃç+³[zv´Åã¾v Só¼¦2«Ogs’9†O®²ºçV¡í‡$ÿ¡g¨şàÆ½çÉ=™‡;²èwÅ5¤'Î ƒªG[J"z—Øñvé*ğÂtAgìíyA¡·êòã^óäÍŸ†ŸJAáÊ“öö¹À!"E Ä½3»ƒ®h”¥àÕ€M§½ñ#¬/ÿCÏPıÁŒ{Î‘{Ãïër¸1¡À:â³²ÊÌÒ˜ë§”“QMÜÛìipcMá|IP³Ïñ…ç»È=Ù¯Æö5½ß[~fö‰x°›¬ 4œYˆµ İ—ÿ:p
àá†zœ}/9ßCîË<}ğ§<¯7dªcsÉä½³\’–çt£¦Œ0´VîàöÑ‰öfÊ³¡z†úœ}¯/‚qÏùrîı4Šj'½[KÁ•‡ˆB=û;/ØÈóØ’ß˜½îAmï= %´øa¡4Ÿ¯?‚qıù{v¯_EìĞ“Êáé9ŒhH2Œğ9i$j,„ŒD9ÕG8^à(³ÎŠ£sŸo¡¤åĞÔÿğ3^ãóÇãñó^tĞmÇ’~Ú‡ÓA1"ÆCÖ¡2µxÈ|åNÙ©¤lqÛ:IõÀû_8ã^óãÌ£¡¿ŸğQı4Y+